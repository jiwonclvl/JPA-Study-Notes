# Chapter10 객체 지향 쿼리 언어

<br>

# 목차

> **[1. Criteria](#Criteria)**
>
> **[2. QueryDSL](#QueryDSL)**
>
> **[3. 네이티브 SQL](#네이티브-SQL)**
>
> **[4. 객체지향 쿼리 심화](#네이티브-SQL)**

<br>

## Criteria

criteria 쿼리는 JPQL을 자바 코드로 작성하도록 도와주는 빌더 클래스 API이다. 

문자가 아닌 코드로 JPQL을 관리하여 **문법 오류를 컴파일 단계에서 잡을 수 있는 장점**이 있지만 **코드가 복잡하고 장황해서 잘 사용하지 않는다.** 

### Criteria의 기본 문법들은 생략하였다. (406 ~ 428) 

> 🚨 Criteria를 통해 동적 쿼리를 구성하면 최소한 공백이나 where, and의 위치로 에러가 발생하지는 않지만, 복잡한 문법으로 코드가 읽기 힘든 단점이 있다. 


<br>

## QueryDSL

Criteria처럼 JPQL 빌더 역할을 하며 Critetia를 대체할 수 있다. 

➡️ **데이터를 조회하는 기능이 특화**되어 있다. 

> 💡 JPA, JDO, JDBC, Hibernate, Search, 몽고 DB 등을 다양하게 지원한다. 

<br>

### QueryDSL 설정

#### 시작

**1. com.mysema.query.jpa.impl.JPAQuery 객체를 생성**

    ➡️ 엔티티 매니저를 생성자에 넘겨준다. 


**2. 사용할 쿼리 타입(Q)를 생성한다.** 

    ➡️ 별칭을 지어주면 해당 별칭을 JPQL에서 사용한다. 
    
    new QMember("m");

<br>

##### 기본 Q 생성

쿼리 타입(Q)는 기본 인스턴스를 보관하고 있다. 

```java
new QMember("m"); // 직접 지정
QMember.member //기본 인스턴스 사용
```

> ✅ 같은 엔티티를 조인하거나 서브쿼리 사용 시 같은 별칭이 사용되기 때문에 이럴 경우에는 직접 지정해서 사용한다. 

> **💡 import static을 이용하면 코드를 더 간결하게 작성할 수 있다.**
> 
> ```java
> import static jpabook.jpashop.domain.QMember.member; // 기본 인스턴스 
> ```


<br>

> **📌 기본 문법은 생략하였다. 추후 사용 시 다시 확인해볼 예정 (433 ~  443 Page)**
> 
- #### 검색 조건 쿼리 

- #### 결과 조회

- #### 페이징과 정렬

- #### 그룹

- #### 조인

- #### 서브 쿼리


<br>


#### 프로젝션과 결과 반환 

select 절에 조회 대상을 지정하는 것을 프로젝션이라고 한다.

1️⃣ **프로젝션이 하나인 경우**

 해당 타입으로 반환한다. 

2️⃣ 여러 컬럼 반환과 튜플

QueryDSL은 기본적으로 Tuple 타입을 사용한다. 

<br>

##### 빈 생성 

쿼리 결과를 엔티티가 아닌 **특정 객체로 받고 싶으면** <ins>빈 생성(Bean Population)기능을 사용</ins>한다. 

- 프로퍼티 접근
- 필드 직접 접근
- 생성자 사용 

`com.musema.query.types.Projections` 사용

---

**1️⃣ Projections.bean()**

수정자(setter)를 사용해서 값을 채운다. 

<br>

**2️⃣ Projections.fields()**

필드에 직접 접근해서 값을 채워준다. 

> 💡 필드를 private로 설정해도 동작한다.  

<br>

**3️⃣  Projections.constructor()**

지정한 프로젝션과 파라미터 순서가 같은 생성자가 필요하다.

<br>

> ⚠️ QueryDSL도 수정, 삭제 같은 배치 쿼리를 지원하는데 JPQL 배치 쿼리와 같이 **영속성 컨텍스트를 무시하고 데이터베이스를 직접 쿼리**한다. 


<br>

## 네이티브 SQL 

특정 데이터베이스에 종속적인 기능이 필요한 경우 JPA에서는 아래와 같이 방법을 제공한다. 

- **특정 데이터베이스만 사용하는 함수**
- **특정 데이터베이스만 지원하는 SQL 쿼리 힌트**
- **인라인 뷰, UNION, INTERSECT**
- **스토어 프로시저**
- **특정 데이터베이스만 지원하는 문법**


➡️ 네이티브  SQL을 사용하면 **엔티티를 조회할 수 있고** JPA가 지원하는 <ins>영속성 컨텍스트의 기능을 그대로 사용할 수 있다. </ins>

### **기본 문법은 생략하였습니다. (444 ~ 456 Page)** 


<br>

## 객체지향 쿼리 심화 

### 벌크 연산 

`executeUpdate() 사용`

> ⚠️ 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다.

 ➡️  🚨영속성 컨텍스트와 데이터베이스에 있는 값이 달라질 수 있는 위험이 있다. 🚨
 
**[해결 방법]**

1. refresh()
2. 벌크 연산 먼저 수행
3. 벌크 연산 수행 후 영속성 컨텍스트 초기화 


<br>

### 영속성 컨텍스트와 JPQL 

#### 쿼리 후 영속 상태인 것과 아닌 것 

JPQL의 조회 대상은 엔티티, 임베디드 타입, 값 타입이 있는데 `JPQL`로 **엔티티를 조회하면 영속성 컨텍스트에서 관리**되지만 <ins>엔티티가 아니면 관리되지 않는다.</ins>

**➡️ 조회한 엔티티와 영속성 컨텍스트** 


<br>

#### JPQL로 조회한 엔티티와 영속성 컨텍스트 

> **💬 영속성 컨텍스트에서 이미 관리하고 있는 Entity가 있는 경우 다시 JPQL로 조회하면 어떻게 될까?**
> 
> ➡️ JPQL로 데이터베이스에서 <ins>조회한 결과를 버리고</ins> 대신에 **영속성 컨텍스트에 있던 엔티티를 반환**한다. 

<br>

> **💬 만약 버리지 않고 새로 검색한 엔티티로 대체하면 어떤 문제가 발생할까?** 
> 
> 🚨 영속성 컨텍스트에 수정 중인 데이터가 사라질 수 있으므로 위험하다. 


### 💡 영속성 컨텍스트는 영속 상태인 엔티티의 동일성을 보장해야한다. 

<br>

### find() VS JPQL

- `find()` 메서드의 경우 엔티티가 영속성 컨텍스트에 있으면 <ins>메모리에서 바로 찾으므로 성능상 이점</ins>이 있다. (1차 캐시)

- `JPQL`은 항상 **데이터베이스에 SQL을 실행해서 결과를 조회**한다. 

## 쿼리와 플러시 모드

### JPQL은 영속성 컨텍스트에 있는 데이터를 고려하지 않고 <ins>데이터베이스에서 데이터를 조회</ins>한다. 

###  ➡️ 따라서 JPQL을 실행하기 전에 영속성 컨텍스트의 내용을 데이터베이스에 반영해야한다❗


> 💡 **쿼리에 설정하는 플러시 모드는 엔티티 매니저에 설정하는 플러시 모드보다 우선권을 가진다.** 


<br>

### 플러시 모드와 최적화 

COMMIT 모드는 트랜잭션을 커밋할 때만 플러시하고 쿼리를 실행할 때는 플러시하지 않는다. 

다만 COMMIT을 사용하면 **쿼리시 발생하는 플러시 횟수를 줄여 성능을 최저과할 수 있다.** 


> 💡 JPA와 달리 JDBC는 AUTO로 설정해도 플러시가 일어나지 않기 때문에 쿼리 실행 직전에 flush를 호출해야한다. 