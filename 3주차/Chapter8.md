# Chapter8 프록시와 연관관계 관리

<br>

# 목차

> **[1. 프록시](#프록시)**
>
> **[2. 즉시 로딩과 지연 로딩](#즉시-로딩과-지연-로딩)**
>
> **[3. 지연 로딩 활용](#지연-로딩-활용)**
>
> **[4. 영속성 전이: CASCADE](#영속성-전이-CASCADE)**
>
> **[5. 고아 객체](#고아-객체)**
> 
> **[6. 영속성 전이 + 고아객체, 생명주기](#영속성-전이--고아객체-생명주기)**


<br>

## 프록시

>  💡 `데이터베이스`는 객체와 달리 **객체 그래프 탐색에서 자유롭지 못하다.** JPA는 이를 해결하기 위해 ➡️ <ins>프록시라는 기술을 사용</ins>한다. 

프록시를 사용하면 연관된 객체를 `사용 시점`에 데이터베이스에서 조회할 수 있다. 

⭕ **자주 함께 사용되는 객체**들은 `조인을 사용해서 함께 조회하는것이 효과적`이다. 

<br>

**[예시]**

회원과 팀의 연관관계가 있는 상황

- 두 정보 모두 필요한 경우
- 하나의 정보만 필요한 경우

**🗨️ 하나의 정보만 필요하다면?**

➡️ 연관관계가 맺어진 <ins>다른 정보를 데이터베이스에서 같이 조회하는 것은 효율적이지 않다.</ins> 

### JPA는 이러한 문제를 해결하기 위해서 엔티티가 실제 사용될 때까지 조회를 지연하는 지연로딩을 제공한다. 

> 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 **가짜 객체가 필요한데 이것을 프록시 객체**라고 한다. 
> 
> ➡️ JPA를 통해 식별자로 실제 객체로 조회하면 엔티티 사용 여부와 상관없이 데이터베이스를 조회한다. 
> 
> 따라서, 이를 대신해줄 프록시 객체가 필요❗ 

<br>

**[실제 엔티티 사용]**

```java
em.find(memberId); // 영속성 컨텍스트에 가서 엔티티가 없는 경우 데이티베이스를 조회한다.
```

연관된 객체가 <ins>한참 후에 필요</ins>해지거나 <ins>아예 필요로 되지 않는 경우</ins>에도 상관없이 **이미 데이터베이스에서 모든 엔티티의 조회가 이루어진다.** 

<br>

**[프록시 사용]**

```java
Member member  = em.getReference(memberId); //프록시 Member 객체의 참조값 (프록시의 참조값만 가지고 있는 상태)
```

객체를 조회해 두면 이후 `필요한 시점`에 해당 **참조 필드를 통해 Team객체와 Team 내의 필드가 참조하고 있는 객체까지 가져와서 자유롭게 사용**할 수 있다.

<br>

> 💡 **프록시 생성 시 JPA는 데이터베이스 조회 및 객체 생성도 하지 않는다.** 

<br>

프록시 객체는 `member.getName()`과 같이 메소드를 호출하면 <ins>**실제 객체 생성**</ins>과 함께 <ins>**데이터베이스에서 값을 조회**</ins>하여 가져온다. 

### ➡️ 프록시 객체의 초기화 

> **참조만 유지하던 프록시 객체**가 `메서드 호출 시` **실제 엔티티로 로드되어 실질적인 데이터를 갖게 된다.**

**[프록시 예상 코드]**

```java
class MemberProxy extends Member {
    Member target = null; //프록시 초기 
    
    public String getName() {
        if(target == null) {
            //초기화
            //DB 조회
            //실제 엔티티 생성 및 참조 보관
            this.target = ...;
        }
        
        target.getName();
        return target.getName();
    }
}
```
> **💡 프록시 객체의 초기화는 한번만 이루어진다.**
> 
> `영속성 컨텍스트`는 **동일한 식별자를 가진 엔티티에 대해 단일 인스턴스를 보장**하기 때문에 <ins>**실제 엔티티의 참조 값을 한번만 보관해두면 계속 사용**</ins>할 수 있다.
> 
> ⚠️ **영속성 컨텍스트가 관리하지 않는 경우, 프록시 초기화가 제대로 동작하지 않을 수 있다.**  ➡️ **실제 엔티티를 가져올 수 없기 때문에(initializationException)**

<br>

### 프록시와 식별자

위의 코드를 살펴보면 `m.getReference(memberId)`로 식별자를 매개변수로 함께 전달한다.

- 프록시 객체는 식별자 값을 가지고 있게되고 이후 `getId()` 호출 시에도 따로 초기화를 하지 않는다. 

> 🔎 `연관관계 설정 시`에는 **식별자 값만 사용**하기 때문에 프록시 사용 시 <ins>데이터베이스 접근 횟수를 줄일 수 있다.</ins>


<br>


### 프록시 확인

**[프록시 초기화 여부]**

`PersistenceUnitUtil.isLoaded(Object entity): ` **초기화되었다면 true**를 **되어있지 않다면 false**를 반환

**[프록시 확인 여부]**

`System.out.println(member.getClass().getMember()):` 프록시일 경우 ..javassist..이라고 뜬다. 

<br>


## 즉시 로딩과 지연 로딩

### 즉시 로딩: 엔티티 조회 시 연관 엔티티도 함께 조회

**설정 방법** ➡️ @ManyToOne(fetch = FetchType.EAGER)

> 🔎 `JPA 구현체`는 **즉시 로딩 최적화**를 위해 <ins>JOIN을 통해 데이터를 조회한다. </ins>

> **⚠️ JPA는 외래 키가 null이 될 수 있는 상황을 고려하여 LEFT_JOIN을 사용한다.** 
> 
> 다만, `외래 키에 NOT NULL 조건을 설정`하여 **값이 있는 것을 보장**하고, 이를 `@JoinColumn(nullable = false)`로 설정한다면 JPA는 INNER_JOIN을 사용한다. 
> 
> **💡 INNER_JOIN의 성능과 최적화에 더 유리하다.** 


<br>

### 지연 로딩

**설정 방법** ➡️ @ManyToOne(fetch = FetchType.LAZY)

<br>

## 지연 로딩 활용: 연관된 엔티티를 실제 사용 시 조회

>  ### 🔎 컬렉션 래퍼
> 
> `엔티티를 영속 상태로 만들 때` **필드 내 컬렉션으로 관리하는 값이 존재**한다면, <ins>컬렉션 추적 및 관리 목적으로 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경</ins>한다.  
> 
> ➡️ 컬렉션 래퍼는 컬렉션을 지연 로딩 처리해준다. 
> 
> `member.getOrders().get(0)`과 같이 호출 시 데이터를 조회하고 컬렉션 래퍼를 초기화한다. 


<br>

> **🚨 컬렉션에 즉시 로딩 사용 시 주의점 🚨**
> 
> - 컬렉션을 하나 이상 즉시 로딩 하는것은 권장하지 않는다. ➡️ 너무 많은 데이터를 반환할 위험이 존재
> - 컬렉션 즉시 로딩은 항상 외부 조인을 사용한다. 

<br>

### 추천 방법: 모든 연관관계에 지연 로딩을 사용하자

### ➡️ 개발 완료단계에서 실제 사용하는 상황을 보고 필요한 곳에만 즉시 로딩을 사용하면 된다. 

<br>

## 영속성 전이: CASCADE

특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶은 경우 사용한다. 

### **[영속성 전이: 저장]**

부모 영속화 시 자식도 함께 영속화

`@OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)`

<br>

### **[영속성 전이: 삭제]**

부모에 저장한 값을 자식에서도 제거하는 경우 (플러시 호출 시 전이 발생)

`@OneToMany(mappedBy = "parent", cascade = CascadeType.REMOVE)`

 ➡️ 설정하지 않으면 외래 키 제약조건으로 데이터베이스에서 외래 키 무결성 예외가 발생한다. 

<br>

## 고아 객체

**부모 엔티티와 연관관계가 끊어진 자식 엔티티**를 <ins>자동으로 삭제해주는 기능을 제공</ins>한다.  
➡️ 이를 `고아 객체(ORPHAN)`라고 한다. 

<br>

참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체롤 보고 삭제하는 기능

**사용법: `@OneToMany(mappedBy = "parent", orphanRemoval = true)`** 

삭제된 객체가 다른 곳에서 참조한다면 문제가 발생할 수 있다.

따라서, **🚨 OneToMany, OneToOne에만 사용한다.🚨**

위의 옵션으로 엔티티 제거 시 데이터베이스의 데이터도 삭제된다. 

> 즉, **부모를 제거하면 자식은 고아가 된다. 따라서, 부모를 제거하면 자식도 같이 제거되어야 된다.**  

<br>

## 영속성 전이 + 고아객체, 생명주기

### 🗨️ 만약 CascaseType.ALL + orpahanRemoval = true를 동시에 사용하면 어떻게 될까?

 ### 💡 부모 엔티티를 통해 자식 엔티티의 생명주기를 관리하게 된다. 

- 자식을 저장하려면 cascade를 통해 부모에서 저장하면된다.
- 자식을 삭제하려면 orphanRemoval or cascade를 통해 부모에서 제거하면 된다. 

