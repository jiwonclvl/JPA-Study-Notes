# Chapter16 트랜잭션과 락, 2차 캐시

<br>

# 목차

> **[1. 트랜잭션과 락](#트랜잭션과-락)**
>
> **[2. 2차 캐시](#2차-캐시)**

<br>

## 트랜잭션과 락

### 트랜잭션과 격리 수준 

트랜잭션은 ACID라 하는 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(durability)를 보장해야한다.

- **원자성:** 모두 성공하거나 모두 실패
- **일관성**: 일관성 있는 데이터베이스 상태 유지 (무결성 제약 조건)
- **격리성:** 트랜잭션 간 영향을 미치지 않도록 해야한다. 
- **지속성:** 트랜잭션 성공 시 그 결과가 항상 기록되어야 한다. 

트랜잭션은 위와 같은 원자성, 일관성, 지속성을 보장한다. 

다만, `격리성을 완벽하게 보장`하려면 **트랜잭션이 순차적으로 이루어져야 한다.**  ➡️ <ins>동시성 처리 성능이 매우 나빠진다.

ANSI 표준은 트랜잭션 격리 수준을 4단계로 나누어 정의하였다. 

<br>

- READ UNCOMMITED: 커밋되지 않은 읽기
- READ COMMITED: 커밋된 읽기 (default)
- REPEATABLE READ: 반복 가능한 읽기
- SERIALIZABLE: 직렬화 가능

<br>

| 격리 수준\문제점 | Dirty Read | Non-Repeatable Read | Phantom Read |
|-----------|-----------|---------------------|--------------|
| READ UNCOMMITED | ⭕         | ⭕                   | ⭕            |
| READ COMMITED |        | ⭕                   | ⭕            |
| REPEATABLE READ |       |                     | ⭕            |
| SERIALIZABLE |   |                     |              |

<br>

#### Dirty Read

수정 중인 데이터를 다른 트랜잭션이 조회할 수 있는 것

➡️ **데이터 정합성에 심각한 문제**가 발생할 수 있다. (ex> 계좌이체) 

<br>

#### Non-Repeatable Read

반복해서 같은 데이터를 읽을 수 없는 상태

**[예시 상황]**

트랜잭션1 ➡️ 회원A (조회 중)

트랜잭션2 ➡️ 회원A (수정 후 커밋)

**트랜잭션1은 수정된 회원A 정보를 조회하게 된다.** 

<br>

#### Phantom Read

반복 조회 시 **결과 집합이 달라지는 것** (ex> 회원 추가)

<br>

### 낙관적 락과 비관적 락 기초 

> ⚠️ **트랜잭션 범위를 넘어서는 문제**
>
> 사용자A,B가 동일한 데이터를 수정한다고 가정
>
> 1️⃣ 사용자 A가 제목 수정 완료
> 2️⃣ 사용자 B가 제목 수정 완료
>
> ➡️ 결과적으로 A의 수정사항은 사라지고 B의 수정사항만 남게되는 <ins>**2번의 분실 문제가 발생**</ins>한다.

**[2번의 분실 문제 해결 방법]**

- 마지막 커밋만 인정 (default)
- 최초 커밋만 인정 (@Version 사용 시 적용)
- 충돌하는 갱신 내용 병합


<br>

#### 🔓 낙관적 락 

트랜잭션 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법 

- @Version 기능 사용 (애플리케이션 제공)

<br>

**💡@Version**
 
**[적용 가능 타입]**
- Long (long)
- Integer (int)
- Short (short)
- Timestamp
 
버전 관리용 필드를 추가하여 @Version을 붙이면 <ins>엔티티를 수정할 때마다 버전이 하나씩 자동 증가</ins>한다. 

⚠️ 엔티티 수정 시 `조회 시점`과 `수정 시점`의 **버전이 다르면 예외 발생**

> 🚨 **벌크 연상은 버전을 무시한다.** 벌크 연산에서 버전을 증가시키려면 강제로 해야한다. 

> **💡LockModeType (JPA가 제공하는 옵션)** 
> 
> | **락 모드**      | **타입**                             | **설명**                                               |
> |-----------|--------------------------------|--------------------------------------------------|
> | 낙관적 락     | `OPTIMISTIC`                   | 낙관적 락을 사용한다.                                     |   
> | 낙관적 락     | `OPTIMISTIC_FORCE_INCREMENT`   | 낙관적 락 + 버전정보를 강제로 증가한다.                          |
> | 비관적 락     | `PESSIMISTIC_READ`             | 비관적 락, 읽기 락을 사용한다.                               |
> | 비관적 락     | `PESSIMISTIC_WRITE`            | 비관적 락, 쓰기 락을 사용한다.                               |
> | 비관적 락     | `PESSIMISTIC_FORCE_INCREMENT`  | 비관적 락 + 버전정보를 강제로 증가한다.                          |
> | 기타        | `NONE`                         | 락을 걸지 않는다.                                       |
> | 기타        | `READ`                         | JPA 1.0 호환 기능. `OPTIMISTIC`과 같음.                 |
> | 기타        | `WRITE`                        | JPA 1.0 호환 기능. `OPTIMISTIC_FORCE_INCREMENT`와 같음. |
>
> ➡️ 옵션을 통해 락을 세밀하게 제어할 수 있다. 

<br>


#### 🔒 비관적 락

트랜잭션 충돌이 발생한다고 가정한 후 락을 거는 방법 

- 데이터베이스가 제공하는 락 기능 사용
- 비관적 락은 주로 PESSIMISTIC_WRITE 모드를 사용

**[특징]**

- 엔티티가 아닌 스칼라 타입을 조회할 때도 사용할 수 있다. 
- 데이터를 수정하는 즉시 트랜잭션 충돌 감지

 📌 **LockModeType에 따른 자세한 내용은 추후 직접 사용할 때 다시 확인해야할 것 같다. (706.Page 참고)** 

> **💡타임아웃**
>
> 비관적 락을 사용하면 락을 획득할 때까지 트랜잭션이 대기
>
> ➡️ 무한정 기다릴 수 없으므로 **타임아웃 시간을 줄 수 있다.** 


<br>

## 2차 캐시 

### 1차 캐시와 2차 캐시 

`애플리케이션 범위`의 캐시를 **공유 캐시** OR **2차 캐시**라고 한다. 

> ⚠️ 네트워크를 통해 **데이터베이스에 접근하는 시간 비용**은 애플리케이션 서버에서 <ins>**내부 메모리에 접근하는 시간 비용보다 수만에서 수십배 이상 비싸다.** 

<br>

**[2차 캐시 적용전]**

![Image](https://github.com/user-attachments/assets/6b6e25a8-031f-49cf-846a-2a3389b4462c)

**[2차 캐시 적용 후]**

![Image](https://github.com/user-attachments/assets/0bb39f9d-7893-4064-b6b4-d466d01f465c)


<br>

#### 1차 캐시 

- 영속성 컨텍스트 내부 존재 
- 엔티티 매니저로 조회하거나 변경하는 모든 엔티티가 저장되어 있다. 
- 트랜잭션 `커밋` 혹은 `플러시` 호출 시 **엔티티 변경 내역이 DB에 동기화**된다. 
- 영속성 컨텍스트 자체가 사실상 1차 캐시 ➡️ on/off 할 수 있는 옵션이 아님

<br>

#### 2차 캐시 

- 애플리케이션에서 공유하는 캐시
- `애플리케이션 종료`까지 **캐시 유지**
- **분산 캐시** 혹은 **클러스터링 환경의 캐시**는 애플리케이션보다 더 오래 유지될 수 있다. 

**[흐름]**

1️⃣ **영속성 컨텍스트**는 엔티티 필요 시 <ins>2차 캐시 조회

2️⃣ 2차 캐시에도 `엔티티가 없으면` <ins>DB 조회 후 결과를 2차 캐시에 저장

3️⃣ 2차 캐시는 자신이 보관하고 있는 엔티티를 복사해서 반환

➡️ 2차 캐시는 **동시성을 극대화하기 위해 복사본을 만들어 반환**한다. 

<br>

**[특징]**

- 영속성 유닛 범위의 캐시
- 복사본을 만들어 반환
- 데이터베이스 기본 키를 기준으로 캐시 But, 영속성 컨텍스트가 다르면 동일성 보장 ❌ (같은 키여도 컨텍스트가 다르면 다른 객체)

<br>

#### JPA 2차 캐시 기능

캐시 모드 설정

앤티티에 **@Cacheable(true or false)로 설정** 

➡️ default: true


<br>

📌 **2차 캐시 설정 및 기능 정리는 생략**하였다. 추후 사용 시 다시 읽어보기 **(712 ~ 717.Page 참고)**

<br>

#### 엔티티 캐시와 컬렉션 캐시 

```mysql
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE) // 엔티티 캐시 
@Entity
public class ParentMember {
      ...
      
      @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
      @OneToMany(mappedBy = "parentMember", cascade = CascadeType.ALL)
      private List<ChildMember> members = new ArrayList<ChildMember>(); //리스트 캐시
} 
```

> **💡@Cache**
> 
> 자세한 기능은 718 ~ 719 page 참고


**[엔티티 캐시 영역]**

패키지명 + 클래스명


**[컬렉션 캐시 영역]**

패키지명 + 클래스명 + 컬렉션 명 


<br>

#### 쿼리 캐시 

쿼리와 파라미터 정보를 키로 사용하여 쿼리 결과를 캐시하는 방법 


**[쿼리 캐시 영역]**

- 쿼리 캐시를 저장하는 영역
- 쿼리 캐시가 유효한지 확인하기 위한 최근 변경 시간을 저장하는 영역



<br>

#### 쿼리 캐시와 컬렉션 캐시의 주의점

쿼리 캐시와 컬렉션 캐시의 경우 <ins>**식별자 값만 캐**시</ins>한다. 

만약, 쿼리, 컬렉션 캐시의 **`대상 엔티티에 캐시를 적용하지 않으면`** 성능상 심각한 문제가 발생할 수 있다. 

**[예시 상황]**

1️⃣ `select m from Member m` 쿼리 시 결과 집합이 100건이라고 가정

2️⃣ 결과 집합에는 식별자만 있으므로 한 건씩 **엔티티 캐시 영역을 조회**한다.  

3️⃣ Member 엔티티는 인티티 캐시를 사용하지 않으므로 **🚨한 건씩 데이터 베이스에서 조회(100번의 SQL 실행)🚨**  

➡️ 따라서 쿼리, 컬렉션 캐시를 사용할 때는 <ins>**결과 대상 엔티티에 꼭 엔티티 캐시를 적용**</ins>해야한다. 