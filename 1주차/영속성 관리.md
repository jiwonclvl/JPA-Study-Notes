# Chapter3 영속성 관리


<br>

# 목차

> **[1. 엔티티 매니저 팩토리와 엔티티 매니저 ](#엔티티-매니저-팩토리와-엔티티-매니저-)**
> 
> **[2. 영속성 컨텍스트란?](#영속성-컨텍스트-persistence-context)**
> 
> **[3. 엔티티의 생명주기](#엔티티의-생명주기-)**
> 
> **[4. 영속성 컨텍스트의 특징](#영속성-컨텍스트의-특징-)**
> 
> **[5. 플러시](#플러시-)**
> 
> **[6. 준영속](#준영속--1)**

<br>

> ### 매핑한 Entity를 엔티티 매니저를 통해 어떻게 사용하는지 알아보자 
> 
> 💡 엔티티 매니저는 엔티티를 `저장`하고, `수정`하고, `삭제`하고, `조회`하는 등의 **엔티티와 관련된 모든일을 처리**한다. (가상의 데이터 베이스로 생각하면 쉽다.)

<br>

## 엔티티 매니저 팩토리와 엔티티 매니저 

![Image](https://github.com/user-attachments/assets/76422bf4-30e9-44e1-86ee-332768be1db1)

`데이터베이스`를 **하나**만 사용하는 애플리케이션은 **하나의 엔티티 매니저 팩토리를 생성**한다.

엔티티 매니저 팩토리를 생성하면 커넥션 풀도 함께 생성되고 이후 엔티티 매니저를 생성하여 다양한 기능을 수행한다. (엔티티 맨니저는 트랜잭션을 시작할 때 커넥션을 흭득한다. )

- `엔티티 매니저 팩토리`는 <span style="color:orange;">**비용이 크기 때문에 한개만 만들어서 공유**</span>한다.
- `엔티티 매니저는` <span style="color:orange;">**비용이 크지 않기 때문에 여러개를 만들어 사용**</span>한다.

  ➡ 엔티티 매니저의경우 여러 스레드가 동시에 접근하면 <span style="color:#F05750;">**동시성 문제가 발생**</span>하기 때문에 <ins>**스레드 간에 절대 공유하면 안된다.**</span>

<br>

> ### 💡 EntityManagerFactory 공유 가능 이유
> 데이터베이스 커넥션 풀을 관리하며 각 요청이 올 때마다 새로운 EntityManager를 생성해 준다.
>
> ➡ 즉, 여러 스레드에서 동시에 호출해도 각 스레드가 독립적인 EntityManager 인스턴스를 받기 때문에 충돌이 발생하지 않는다.

> ### 💡 EntityManager 공유 불가능 이유
> 같은 EntityManager를 여러 스레드가 공유하면 동일한 영속성 컨텍스트를 여러 스레드가 동시에 조작할 수 있는 위험이 있기 때문에 충돌이 발생할 수 있다.  
>
> - 데이터 정합성 문제 발생 가능
>
> - 트랜잭션 충돌 발생 가능
> - 엔티티 상태 불일치
>
> [스프링과 EntityManager의 동시성 비밀](https://woodcock.tistory.com/35) **2021.11.20 자료**

<br>

## 영속성 컨텍스트 (Persistence Context)

영속성 컨테스트란 `엔티티를 영구 저장하는 환경`을 의미한다. 

엔티티 매니저를 통해 엔티티의 저장 및 조회 시 엔티티 매니저는 **영속성 컨텍스트에 엔티티를 보관하고 관리**한다. 


영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어지며, 엔티티 매니저를 통해 영속성 컨텍스트에 접근 및 관리 할 수 있다. 

> 💡 여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근할 수 있다. 


<br>

### 엔티티의 생명주기 

- `비영속(new/transient):` 영속성 컨텍스트와 전혀 연관이 없다.  
- `영속 (managed):` 영속성 컨텍스트에 저장된 상태
- `준영속 (detached):` 저장되었가가 분리된 상태
- `삭제 (removed):` 삭제된 상태

<br>

#### 비영속 

엔티티 객체를 생성한 순수한 객체 상태이며 아직 **영속성 컨텍스트에 저장하지 않았다.** 

![Image](https://github.com/user-attachments/assets/e6da5163-db12-466a-bd20-19d6efc4c402)

<br>

#### 영속 

엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태이다. 

![Image](https://github.com/user-attachments/assets/66583981-205f-448b-b706-4c0f59253239)

<br>

#### 준영속 

영속성 컨텍스트가 관리하던 엔티티를 컨텍스트가 더 이상 관리하지 않으면 준영속 상태가 된다.

> 💡 영속성 컨텍스트를 초기화하면 컨텍스트가 관리하던 모든 엔티티는 준영속 상태가 된다. 


<br>

#### 삭제 

영속성 컨텍스트와 데이터베이스에서 삭제된 상태이다. 

<br>

### 영속성 컨텍스트의 특징 

- 영속성 컨텍스트는 **엔티티를 식별자값 (@Id를 통해 매핑한 값)으로 구분**한다. 

  ➡ ️ 영속 상태는 <span style="color:orange;">**식별자 값이 반드시 있어야 한다.**</span> (없으면 예외 발생)

<br>

- 영속성 컨텍스트에 저장된 엔티티는 `트랜잭션이 커밋하는 순간` <span style="color:orange;">**데이터베이스에 반영**</span>된다. **(플러쉬- flush)** 

<br>

**[영속성 컨텍스트가 엔티티 관리 시 아래와 같은 장점이 존재한다. ]**

- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연 
- 변경감지
- 지연로딩

<br>

### 엔티티 조회 (1차 캐시) 

영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 1차 캐시라고 한다. 

> 💡 내부에는 Map이 하나 존재하며 Key : value 형태로 구성되어 있다. 
> 
> `Key:` @Id로 매핑한 식별자
> 
> `Value:` 엔티티 인스턴스 

![Image](https://github.com/user-attachments/assets/a0ef1e71-9d66-4d0a-8017-79a0497361e2)

📌 영속성 컨텍스트에 데이터를 **저장하고 조회하는 모든 기준**은 데이터베이스의 `기본 키(PrimaryKey)`이다. 

➡ ️ find() 호출 시 우선적으로 **1차 캐시에서 엔티티를 찾고** `존재하지 않는다면` **데이터베이스에서 값을 조회**한다. 

<br>

> ### 1차 캐시에서의 조회 
> 
> ![Image](https://github.com/user-attachments/assets/fae1ecb1-1331-47cc-9c28-5c1e28dc0bec)
> 
> 우선 1차 캐시에서 식별자 값을 통해 엔티티를 찾는다. 
> 
> ➡ <span style="color:orange;">**메모리**</span>에 있는 **1차 캐시에서 엔티티 조회** 
> 
> **💬 1차 캐시에서 엔티티를 조회하면 DB에 불필요한 커넥션을 맺지 않고 메모리에서 바로 가져올 수 있기 때문에 성능적으로 유리한건가? 따로 쿼리를 날려서 조회하지 않아도 된다.**

<br>

> ### 데이터베이스에서의 조회 
> 
> `1차 캐시에서 엔티티를 찾을 수 없는 경우` **엔티티 매니저**는 <ins>**데이터 베이스를 조회하여 엔티티를 생성**</ins>한다. 
> 
> ➡ 그 후 찾은 엔티티를 **1차 캐시에 저장한 후 영속 상태의 엔티티를 반환**한다.  


<br>

### 영속 엔티티의 동일성 보장

영속성 컨텍스트는 <span style="color:orange;">**1차 캐시에 있는 엔티티 인스턴스를 반환**</span>한다. 

따라서 == 비교를 한다면 ture의 결과 값을 낸다.
➡  이를 통해 <ins>**엔티티의 동일성을 보장**</ins>한다. 


> 💬 JPA는 1차 캐시를 통해 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공 -> 이해안감 

<br>

### 엔티티 등록 (쓰기 지연)
![Image](https://github.com/user-attachments/assets/4ea25da1-2fe6-43e2-ba53-e9434bc637d8)

**엔티티 매니저는 트랜잭션을 커밋하기 전까지** 데이터 베이스에 엔티티를 저장하지 않고 <ins>**SQL을 내부 쓰기 지연 SQL 저장소에 모아둔다.**</ins>

`트랜잭션 커밋 후` 해당 SQL 쿼리를 데이터베이스에 전달한다. ➡ 이를  <span style="color:orange;">쓰**기지연**</span>이라고 한다.

> 💡 `flush()`를 통해 <ins>**영속성 컨텍스트의 변경 내용을 데이터베이스와 먼저 동기화**</ins> 한 후
 `commit()`을 실행하여 <ins>**실제 데이터베이스 트랜잭션을 반영**</ins>한다.

<br>

### 엔티티 수정 (변경 감지 -Dirty Checking)

> 💡 **[SQL 수정 쿼리의 문제점]** 
>
> SQL을 사용하면 **개발자가 직접 수정 쿼리를 작성**해야 하며 **수정할 사항이 많아질수록 쿼리 수도 증가**한다. 
>
> ➡ 이에 따라 비즈니스 로직이 복잡해지고, 개발자는 <span style="color:#F05750;">**지속적으로 SQL을 확인하고 수정**</span>해야 한다. **(SQL 의존적)**

<br>

JPA는 엔티티를 수정할 때 `변경감지 기능`을 사용한다. 

![Image](https://github.com/user-attachments/assets/1b278c0a-a4fb-4ffa-8cac-bcf2b4ea3680)


**[흐름]**

1. 트랜잭션 커밋시 엔티티 매니저 내부에서 플러쉬 호출
2. `스냅샷과 엔티티 비교시 변경된 엔티티가 있다면` **수정 쿼리 생성 후 쓰기 지연 SQL 저장소에 보관**
3. 저장소의 쿼리를 데이터 베이스에 전달 
4. 데이터 베이스 트랜잭션 커밋

> #### 🔴 변경 감지 기능은 영속 상태의 엔티티에만 적용된다. 즉, 다른 상태의 엔티티는 변경되어도 데이터베이스에 반영 ❌
> 
> #### ⚠️ 엔티티의 모든 필드를 업데이트한다. 즉, 수정된 데이터 외에도 업데이트를 진행한다. <span style="color:#F05750;">**(전송략 증가)**</span>
> 

> #### **💬 필드가 많거나 내용이 너무 크다면?** 
> 
> 수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성해야한다. (@DynamicInsert 사용)
> 
> > 테이블에 컬럼이 30개 이상이라면 테이블 설계가 적절하지 않다는 의미이다.  


<br>

### 엔티티 삭제 

삭제 대상 조회 후 삭제 쿼리를 쓰기 지연 SQL에 등록하고 커밋이되면 영속성 컨텍스트에서 제거된다. 

이때, 엔티티는 재사용하지 말고 **자연스럽게 가비지 컬렉션의 대상이 되도록 두는 것**이 좋다. 

## 플러시 

플러시는 영속성 컨텍스트의 **변경 내용을 데이터베이스에 동기화하는 것**을 말한다. 


[플러시 방법]

1. flush 직접 호출 (거의 사용 X)
2. 트랜잭션 커밋 시 자동 호출 
3. JPQL 쿼리 실행 시 자동 호출 


<br>

## 준영속 

### [준영속 상태로 전환하는 방법] 

개발자가 직접 준영속 상태를 만드는 일은 드물다.
- detach()
- clear() 초기화
- close() 종료

메소드 호출 시 영속성 컨텍스트의 **1차 캐시, 쓰기지연 SQL 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거**된다. 

<br>

### [특징]
- 거의 비영속 상태와 가깝다. 
- 이미 한번은 영속 상태였기 때문에 반드시 식별자 값을 가지고 있다. 
- 지연로딩 불가능 (프록시 객체 사용 불가능)

<br>

### [다시 영속 상태로 만드는 방법]

merge()  

**준영속 상태의 엔티티를 받아서 해당 정보로 새로운 영속 상태의 엔티티를 반환**한다. (비영속도 가능하다.)

흐름은 다음과 같다. 
1. merge 실행
2. 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차캐시에서 엔티티 조회 
3. 1차 캐시에 데이터가 없다면 데이터 베이스에서 조회 후 1차 캐시에 저장 
4. 조회한 엔티티에 넘어온 엔티티의 값을 넣어준다. 

> 💡 식별자 값으로 엔티티를 조회할 수 있다면, 해당 데이터를 불러서 병합하고 없다면 새로 생성해서 병합한다. 